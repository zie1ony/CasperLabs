#![no_std]

extern crate bn;
extern crate contract;
extern crate alloc;

use contract::contract_api::runtime;
use types::ApiError;
use alloc::vec::Vec;

pub struct Proof {
    pub a_g1: bn::G1,
    pub b_g2: bn::G2,
    pub c_g1: bn::G1
}

pub struct VerifyingKey {
    pub alpha_g1: bn::G1,
    pub beta_g2: bn::G2,
    pub gamma_g2: bn::G2,
    pub delta_g2: bn::G2,
    pub ic: Vec<bn::G1>
}

pub fn to_g1(x_str: &str, y_str: &str) -> bn::G1 {
    let x = bn::Fq::from_str(x_str).unwrap();
    let y = bn::Fq::from_str(y_str).unwrap();
    bn::AffineG1::new(x, y).unwrap().into()
}

pub fn to_g2(
    x_b_str: &str, 
    x_a_str: &str, 
    y_b_str: &str,
    y_a_str: &str 
) -> bn::G2 {
    let x_a = bn::Fq::from_str(x_a_str).unwrap();
    let x_b = bn::Fq::from_str(x_b_str).unwrap();
    let x = bn::Fq2::new(x_a, x_b);
    let y_a = bn::Fq::from_str(y_a_str).unwrap();
    let y_b = bn::Fq::from_str(y_b_str).unwrap();
    let y = bn::Fq2::new(y_a, y_b);
    bn::AffineG2::new(x, y).unwrap().into()
}

fn verify(vk: &VerifyingKey, proof: &Proof, input: &bn::Fr) -> bool {
    let alpha_g1_beta_g2 = bn::pairing(vk.alpha_g1, vk.beta_g2);
    let neg_gamma_g2 = -vk.gamma_g2;
    let neg_delta_g2 = -vk.delta_g2;

    let acc = vk.ic[0] + (vk.ic[1] * *input);

    let mut result = bn::miller_loop_batch(&[
        (proof.b_g2, proof.a_g1),
        (neg_gamma_g2, acc),
        (neg_delta_g2, proof.c_g1)
    ]).unwrap();
    result = result.final_exponentiation().unwrap();
    result == alpha_g1_beta_g2
}

#[no_mangle]
pub extern "C" fn call() {
    Input
    let input = bn::Fr::from_str("1").unwrap();

    // Proof
    let a_g1 = to_g1(
        "13609732548209635204283762717377673323371234630801498076890772245913794172759",
        "8505402217898444616565144346519027068193667977978839437662775620437921685452"
    );
    let b_g2 = to_g2(
        "20349385719647222401094665469983833918973363307317669502751024758050496470150",
        "9398348294597904954821337508035100700830736395296362510311298162107272247524",
        "20154102955704489614231200138904109355314181641377075118305418664463505002197", 
        "4207735773356923206147957921445638390883469735462864491355298707095277054777"
    );
    let c_g1 = to_g1(
        "17156063102031880290292312838273204553033042625614462490193930218903169342779", 
        "20520097851431218672483033086233665057589073036752561704445141904026145267946"
    );
    let proof = Proof { a_g1, b_g2, c_g1 };

    // VK.
    let alpha_g1 = to_g1(
        "11093650441438000950757827803278854813671004258182083598009560058249596239296", 
        "525081214882598573137446837460289594627433424379478911559764104085186479988"
    );
    let beta_g2 = to_g2(
        "18635979808191813270245865752016906009778755165291207270503472186718203537886", 
        "5663202211210988941446215168381359354751571199369352756521391807530308222327",
        "12456313135790412797890612981563228499906620001684025033841994753676406282889", 
        "8185109970769563802265164928325154142994103675763687622090546585534400042106"
    );
    let gamma_g2 = to_g2(
        "4036269987512214043905480980413480179909916002804036473899075534671982616889", 
        "11656258096986835157170798999406978713637579562562890781603877008350484258983",
        "5930159426768539392259913590414671309188351183296299021685476566841644955052",
        "9227451214503982574359115977263077462959340765839116478565015047205642172528"
    );
    let delta_g2 = to_g2(
        "12103057102887711800530708324227299908506991619938131422769724125179594927329", 
        "19420598441141347063334739518705919858604316989912183056049982951722913522782", 
        "21610948836028779781055235878253596144399630996712993407178558529696714029329", 
        "6766972684216814320025612943137680912185864065621832237544437684848792370795"
    );
    let ic_0 = to_g1(
        "7568227155077029100920526584772612611093170484414558583747806689762767513792",
        "17027720534733442831083813041804618430078742257777736949174971376510025120253"
    );
    let ic_1 = to_g1(
        "4908934989313331945323423154813249485652518638814322668374278032565982925728",
        "12314545109225873122182479796359347433869874839382355629528918487888661283746"
    );
    let mut ic = Vec::new();
    ic.push(ic_0);
    ic.push(ic_1);
    let vk = VerifyingKey { alpha_g1, beta_g2, gamma_g2, delta_g2, ic };

    let result = verify(&vk, &proof, &input);

    if !result {
        runtime::revert(ApiError::User(1u16))
    }
}
